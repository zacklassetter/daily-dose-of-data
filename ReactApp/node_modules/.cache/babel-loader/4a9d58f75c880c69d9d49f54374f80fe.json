{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\zack\\\\source\\\\repos\\\\Quinten\\\\Web_Project\\\\ReactApp\\\\src\\\\QuickSort\\\\QuickSortInformation.js\";\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst QuickSortInformation = () => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"information\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Quick Sort\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Quick sort is a divide-and-conquer algorithm. It involves first selecting a pivot and then swapping elements and moving the pivot such that all elements to the left of the pivot are less than the pivot and all elements to the right of the pivot are greater. The greater and less than values are then partitioned into two subarrays and the process is repeated recursiveley.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"The choice of the pivot is open to some variation. In this visualization we chose to use the last element in each partition as the pivot. Thus, a single partition is processed by first designating the last element in the partition as the pivot. Next, a low pointer is placed on the lower bound index of the partition and a high pointer is placed on the higher bound index of the parition. The low pointer then moves rightward until and element is found that is greater than the pivot element. The high pointer follows suit by moving leftward until it finds an element that is less than the pivot element. When both the low and high pointers find their target they perform a swap. The pointers then both move again, repeating the process, until they cross. Crossed pointers indicate the sorted location of the pivot element. Thus, the pivot is moved to that location and the array is re-pratitioned into a lower and upper partition. The entire procedure is then repeated until all elements are sorted.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"To find the minimum element of the unsorted subarray, a linear scan is used where the smallest element is kept track of. Then the minimum can be swapped with the beginning in costant time. The linear scan portion takes n comparisons the first time, n-1 comparisons the second time, and so on until there is 1 comparison on the last scan. Because of this the overall time complexity is O(n\", /*#__PURE__*/_jsxDEV(\"sup\", {\n        children: \"2\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 404\n      }, this), \"). Since all of the swaps are done in place for selection sort, the space complexity is constant.\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"table\", {\n      children: /*#__PURE__*/_jsxDEV(\"tbody\", {\n        children: [/*#__PURE__*/_jsxDEV(\"tr\", {\n          children: [/*#__PURE__*/_jsxDEV(\"th\", {\n            children: \"Selection Sort\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 15,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"th\", {\n            children: \"Complexity\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 15,\n            columnNumber: 48\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 15,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"tr\", {\n          children: [/*#__PURE__*/_jsxDEV(\"td\", {\n            children: \"Time Complexity\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 16,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"td\", {\n            children: [\"O(n\", /*#__PURE__*/_jsxDEV(\"sup\", {\n              children: \"2\"\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 16,\n              columnNumber: 56\n            }, this), \")\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 16,\n            columnNumber: 49\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 16,\n          columnNumber: 21\n        }, this), /*#__PURE__*/_jsxDEV(\"tr\", {\n          children: [/*#__PURE__*/_jsxDEV(\"td\", {\n            children: \"Space Complexity\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 17,\n            columnNumber: 25\n          }, this), /*#__PURE__*/_jsxDEV(\"td\", {\n            children: \"O(1)\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 17,\n            columnNumber: 50\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 17,\n          columnNumber: 21\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 14,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 5,\n    columnNumber: 9\n  }, this);\n};\n\n_c = QuickSortInformation;\nexport default QuickSortInformation;\n\nvar _c;\n\n$RefreshReg$(_c, \"QuickSortInformation\");","map":{"version":3,"sources":["C:/Users/zack/source/repos/Quinten/Web_Project/ReactApp/src/QuickSort/QuickSortInformation.js"],"names":["React","QuickSortInformation"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;;;AAEA,MAAMC,oBAAoB,GAAG,MAAM;AAC/B,sBACI;AAAK,IAAA,SAAS,EAAC,aAAf;AAAA,4BACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFJ,eAGI;AAAA;AAAA;AAAA;AAAA,YAHJ,eAII;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAJJ,eAKI;AAAA;AAAA;AAAA;AAAA,YALJ,eAMI;AAAA,saAAuY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cAAvY;AAAA;AAAA;AAAA;AAAA;AAAA,YANJ,eAOI;AAAA;AAAA;AAAA;AAAA,YAPJ,eAQI;AAAA,6BACI;AAAA,gCACI;AAAA,kCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAJ,eAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA3B;AAAA;AAAA;AAAA;AAAA;AAAA,gBADJ,eAEI;AAAA,kCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAJ,eAA4B;AAAA,2CAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAP;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA5B;AAAA;AAAA;AAAA;AAAA;AAAA,gBAFJ,eAGI;AAAA,kCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAJ,eAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAA7B;AAAA;AAAA;AAAA;AAAA;AAAA,gBAHJ;AAAA;AAAA;AAAA;AAAA;AAAA;AADJ;AAAA;AAAA;AAAA;AAAA,YARJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAkBH,CAnBD;;KAAMA,oB;AAqBN,eAAeA,oBAAf","sourcesContent":["import React from 'react';\r\n\r\nconst QuickSortInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <h1>Quick Sort</h1>\r\n            <p>Quick sort is a divide-and-conquer algorithm. It involves first selecting a pivot and then swapping elements and moving the pivot such that all elements to the left of the pivot are less than the pivot and all elements to the right of the pivot are greater. The greater and less than values are then partitioned into two subarrays and the process is repeated recursiveley.</p>\r\n            <br />\r\n            <p>The choice of the pivot is open to some variation. In this visualization we chose to use the last element in each partition as the pivot. Thus, a single partition is processed by first designating the last element in the partition as the pivot. Next, a low pointer is placed on the lower bound index of the partition and a high pointer is placed on the higher bound index of the parition. The low pointer then moves rightward until and element is found that is greater than the pivot element. The high pointer follows suit by moving leftward until it finds an element that is less than the pivot element. When both the low and high pointers find their target they perform a swap. The pointers then both move again, repeating the process, until they cross. Crossed pointers indicate the sorted location of the pivot element. Thus, the pivot is moved to that location and the array is re-pratitioned into a lower and upper partition. The entire procedure is then repeated until all elements are sorted.</p>\r\n            <br />\r\n            <p>To find the minimum element of the unsorted subarray, a linear scan is used where the smallest element is kept track of. Then the minimum can be swapped with the beginning in costant time. The linear scan portion takes n comparisons the first time, n-1 comparisons the second time, and so on until there is 1 comparison on the last scan. Because of this the overall time complexity is O(n<sup>2</sup>). Since all of the swaps are done in place for selection sort, the space complexity is constant.</p>\r\n            <br />\r\n            <table>\r\n                <tbody>\r\n                    <tr><th>Selection Sort</th><th>Complexity</th></tr>\r\n                    <tr><td>Time Complexity</td><td>O(n<sup>2</sup>)</td></tr>\r\n                    <tr><td>Space Complexity</td><td>O(1)</td></tr>\r\n                </tbody>\r\n            </table>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default QuickSortInformation;"]},"metadata":{},"sourceType":"module"}