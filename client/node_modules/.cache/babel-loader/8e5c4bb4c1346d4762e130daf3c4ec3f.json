{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\qdeman\\\\Documents\\\\Daily_Dose_of_Data\\\\ReactApp\\\\src\\\\BinarySearchTree\\\\BinarySearchTreeInformation.js\";\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst BinarySearchTreeInformation = () => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"information\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Binary Search Tree\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"A Binary Search Tree is a tree data structure where elements are kept in an ordered pattern. For any given node, all of the elements in the left sub-tree are less than or equal to the given node, and all of the elements in the right sub-tree are greater than or equal to the given node.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: /*#__PURE__*/_jsxDEV(\"u\", {\n        children: \"A Binary Search Tree has the following basic operations:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 9,\n        columnNumber: 16\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: [/*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: \"Insert:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 11,\n          columnNumber: 21\n        }, this), \" inserts an element into tree\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: \"Remove:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 12,\n          columnNumber: 21\n        }, this), \" removes an element from the tree\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 12,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: \"Find:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 13,\n          columnNumber: 21\n        }, this), \" searches for an element in the tree\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 13,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"In order to maintain the ordered property of the tree, insertion and removal of elements must be done in a careful manner. For insertion the tree is traversed going left if new value is less than the current node and going right if the new value is greater than the current node. Once we reach an empty spot, a new node is created there with the new value.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"To remove a value from the tree, it becomes more complex. First we traverse the tree to find the node of the value we want to remove. If it has no children, we simply set its parent's child to null. If it has 1 child, we set its parent's child to its child. If it has 2 children, we find the leftmost child of the right sub-tree of the current node, set the current node to that value, and then delete the leftmost child of the right sub-tree. This can also be done with the rightmost child of the left sub-tree.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 18,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 5,\n    columnNumber: 9\n  }, this);\n};\n\n_c = BinarySearchTreeInformation;\nexport default BinarySearchTreeInformation;\n\nvar _c;\n\n$RefreshReg$(_c, \"BinarySearchTreeInformation\");","map":{"version":3,"sources":["C:/Users/qdeman/Documents/Daily_Dose_of_Data/ReactApp/src/BinarySearchTree/BinarySearchTreeInformation.js"],"names":["React","BinarySearchTreeInformation"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;;;AAEA,MAAMC,2BAA2B,GAAG,MAAM;AACtC,sBACI;AAAK,IAAA,SAAS,EAAC,aAAf;AAAA,4BACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFJ,eAGI;AAAA;AAAA;AAAA;AAAA,YAHJ,eAII;AAAA,6BAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAH;AAAA;AAAA;AAAA;AAAA,YAJJ,eAKI;AAAA,8BACI;AAAA,gCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,cADJ,eAEI;AAAA,gCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,cAFJ,eAGI;AAAA,gCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,cAHJ;AAAA;AAAA;AAAA;AAAA;AAAA,YALJ,eAUI;AAAA;AAAA;AAAA;AAAA,YAVJ,eAWI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAXJ,eAYI;AAAA;AAAA;AAAA;AAAA,YAZJ,eAaI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAbJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAiBH,CAlBD;;KAAMA,2B;AAoBN,eAAeA,2BAAf","sourcesContent":["import React from 'react';\r\n\r\nconst BinarySearchTreeInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <h1>Binary Search Tree</h1>\r\n            <p>A Binary Search Tree is a tree data structure where elements are kept in an ordered pattern. For any given node, all of the elements in the left sub-tree are less than or equal to the given node, and all of the elements in the right sub-tree are greater than or equal to the given node.</p>\r\n            <br />\r\n            <p><u>A Binary Search Tree has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into tree</li>\r\n                <li><b>Remove:</b> removes an element from the tree</li>\r\n                <li><b>Find:</b> searches for an element in the tree</li>\r\n            </ul>\r\n            <br />\r\n            <p>In order to maintain the ordered property of the tree, insertion and removal of elements must be done in a careful manner. For insertion the tree is traversed going left if new value is less than the current node and going right if the new value is greater than the current node. Once we reach an empty spot, a new node is created there with the new value.</p>\r\n            <br />\r\n            <p>To remove a value from the tree, it becomes more complex. First we traverse the tree to find the node of the value we want to remove. If it has no children, we simply set its parent's child to null. If it has 1 child, we set its parent's child to its child. If it has 2 children, we find the leftmost child of the right sub-tree of the current node, set the current node to that value, and then delete the leftmost child of the right sub-tree. This can also be done with the rightmost child of the left sub-tree.</p>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinarySearchTreeInformation;"]},"metadata":{},"sourceType":"module"}