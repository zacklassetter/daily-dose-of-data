{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\qdeman\\\\Documents\\\\Daily_Dose_of_Data\\\\ReactApp\\\\src\\\\BinarySearchTree\\\\BinarySearchTreeInformation.js\";\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst BinarySearchTreeInformation = () => {\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"information\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"Binary Search Tree\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 6,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"A Binary Search Tree is a tree data structure where elements are kept in an ordered pattern. For any given node, all of the elements in the left sub-tree are less than or equal to the given node, and all of the elements in the right sub-tree are greater than or equal to the given node.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: /*#__PURE__*/_jsxDEV(\"u\", {\n        children: \"A Binary Search Tree has the following basic operations:\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 9,\n        columnNumber: 16\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"ul\", {\n      children: [/*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: \"Insert:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 11,\n          columnNumber: 21\n        }, this), \" inserts an element into tree\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 11,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: \"Remove:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 12,\n          columnNumber: 21\n        }, this), \" removes an element from the tree\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 12,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"li\", {\n        children: [/*#__PURE__*/_jsxDEV(\"b\", {\n          children: \"Find:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 13,\n          columnNumber: 21\n        }, this), \" searches for an element in the tree\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 13,\n        columnNumber: 17\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"In order to maintain the ordered property of the tree, insertion and removal of elements must be done in a careful manner. For insertion the tree is traversed going left if new value is less than the current node and going right if the new value is greater than the current node. Once we reach an empty spot, a new node is created there with the new value.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"To remove a value from the tree, it becomes more complex.\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 5,\n    columnNumber: 9\n  }, this);\n};\n\n_c = BinarySearchTreeInformation;\nexport default BinarySearchTreeInformation;\n\nvar _c;\n\n$RefreshReg$(_c, \"BinarySearchTreeInformation\");","map":{"version":3,"sources":["C:/Users/qdeman/Documents/Daily_Dose_of_Data/ReactApp/src/BinarySearchTree/BinarySearchTreeInformation.js"],"names":["React","BinarySearchTreeInformation"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;;;AAEA,MAAMC,2BAA2B,GAAG,MAAM;AACtC,sBACI;AAAK,IAAA,SAAS,EAAC,aAAf;AAAA,4BACI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YADJ,eAEI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAFJ,eAGI;AAAA;AAAA;AAAA;AAAA,YAHJ,eAII;AAAA,6BAAG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAH;AAAA;AAAA;AAAA;AAAA,YAJJ,eAKI;AAAA,8BACI;AAAA,gCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,cADJ,eAEI;AAAA,gCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,cAFJ,eAGI;AAAA,gCAAI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAJ;AAAA;AAAA;AAAA;AAAA;AAAA,cAHJ;AAAA;AAAA;AAAA;AAAA;AAAA,YALJ,eAUI;AAAA;AAAA;AAAA;AAAA,YAVJ,eAWI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAXJ,eAYI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAZJ;AAAA;AAAA;AAAA;AAAA;AAAA,UADJ;AAgBH,CAjBD;;KAAMA,2B;AAmBN,eAAeA,2BAAf","sourcesContent":["import React from 'react';\r\n\r\nconst BinarySearchTreeInformation = () => {\r\n    return (\r\n        <div className=\"information\">\r\n            <h1>Binary Search Tree</h1>\r\n            <p>A Binary Search Tree is a tree data structure where elements are kept in an ordered pattern. For any given node, all of the elements in the left sub-tree are less than or equal to the given node, and all of the elements in the right sub-tree are greater than or equal to the given node.</p>\r\n            <br />\r\n            <p><u>A Binary Search Tree has the following basic operations:</u></p>\r\n            <ul>\r\n                <li><b>Insert:</b> inserts an element into tree</li>\r\n                <li><b>Remove:</b> removes an element from the tree</li>\r\n                <li><b>Find:</b> searches for an element in the tree</li>\r\n            </ul>\r\n            <br />\r\n            <p>In order to maintain the ordered property of the tree, insertion and removal of elements must be done in a careful manner. For insertion the tree is traversed going left if new value is less than the current node and going right if the new value is greater than the current node. Once we reach an empty spot, a new node is created there with the new value.</p>\r\n            <p>To remove a value from the tree, it becomes more complex.</p>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default BinarySearchTreeInformation;"]},"metadata":{},"sourceType":"module"}